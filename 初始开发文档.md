# 颗粒称重包装机自适应控制系统开发文档

## 1. 项目概述

### 1.1 项目目标
开发一个具有高度模块化、健壮和可维护性的自适应控制系统，通过MODBUS RTU协议与PLC通信，实现颗粒称重包装机的三阶段（快加、慢加、点动）自适应控制，使系统能够自动调整参数以达到目标重量，同时提供直观的用户界面进行实时监控和灵活配置。

### 1.2 系统特点
- 基于三阶段控制策略（快加、慢加、点动）
- 集成实时监控和可视化界面
- 灵活的通信参数配置界面
- 自适应算法动态调整控制参数
- 实时数据显示与分析功能
- 多斗独立控制与监控
- 参数变化趋势可视化
- 高度模块化、易于维护的代码架构
- 完善的错误处理和异常机制
- 全面的测试覆盖
- 容器化部署支持

## 2. 系统架构

### 2.1 总体架构

系统采用模块化设计，分为以下几个主要部分，UI与功能模块紧密集成：

```
颗粒称重包装机自适应控制系统
│
├── 用户界面模块 (UI)
│   ├── 连接配置界面
│   ├── 实时监控界面
│   ├── 参数设置界面
│   ├── 数据可视化
│   └── 周期数据分析
│
├── 通信模块 (Communication)
│   ├── MODBUS RTU通信
│   ├── 数据转换
│   └── 错误处理
│
├── 数据采集模块 (DataAcquisition)
│   ├── 状态监测
│   ├── 周期检测
│   └── 数据记录
│
├── 自适应算法模块 (AdaptiveAlgorithm)
│   ├── 三阶段参数调整
│   ├── PID控制
│   └── 性能评估
│
└── 控制模块 (Controller)
    ├── 主控制逻辑
    ├── 参数管理
    └── 系统调度
```

### 2.2 模块关系图

```
                +------------------+
                |      PLC         |
                +------------------+
                        ^
                        |
               +----------------+
               |   通信模块     |
               +----------------+
                 ^     ^     ^
                 |     |     |
    +------------+     |     +------------+
    |                  |                  |
+----------+   +---------------+   +--------------+
| 控制模块 |<->| 自适应算法模块 |<->| 数据采集模块 |
+----------+   +---------------+   +--------------+
    ^  ^  ^       ^      ^            ^     ^
    |  |  |       |      |            |     |
    |  |  +-------+      +------------+     |
    |  |                                    |
    |  +------------------------------------+
    |                                       |
    v                                       v
+----------------------------------------------+
|                用户界面模块                   |
+----------------------------------------------+
```

UI模块是系统的核心组成部分，与各功能模块直接交互，实现数据的实时显示和用户操作的直接响应。

## 3. 模块设计

### 3.1 通信模块 (Communication)

#### 3.1.1 功能描述
负责通过MODBUS RTU协议与PLC进行通信，实现数据读取和参数写入。

#### 3.1.2 接口定义

**类：ModbusRTUClient**

```python
class ModbusRTUClient:
    """
    MODBUS RTU通信客户端
    负责与PLC进行数据交换
    """
    
    def __init__(self, port, baudrate, bytesize, parity, stopbits, timeout):
        """初始化通信客户端"""
        pass
        
    def connect(self):
        """建立连接"""
        pass
        
    def disconnect(self):
        """断开连接"""
        pass
        
    def read_register(self, address, count=1, unit=1):
        """读取保持寄存器"""
        pass
        
    def write_register(self, address, value, unit=1):
        """写入保持寄存器"""
        pass
        
    def read_coil(self, address, count=1, unit=1):
        """读取线圈"""
        pass
        
    def write_coil(self, address, value, unit=1):
        """写入线圈"""
        pass
        
    def read_discrete_input(self, address, count=1, unit=1):
        """读取离散输入"""
        pass
        
    def read_input_register(self, address, count=1, unit=1):
        """读取输入寄存器"""
        pass
```

**类：PLCCommunicator**

```python
class PLCCommunicator:
    """
    PLC通信管理器
    提供高级数据读写接口，封装MODBUS细节
    """
    
    def __init__(self, modbus_client, address_mapper):
        """初始化PLC通信管理器"""
        pass
        
    def read_weight(self, hopper_id):
        """读取指定料斗的重量"""
        pass
        
    def read_status(self, hopper_id):
        """读取指定料斗的状态"""
        pass
        
    def write_parameter(self, param_type, hopper_id, value):
        """写入参数到PLC"""
        pass
        
    def send_command(self, command_type, hopper_id=None):
        """发送控制命令"""
        pass
        
    def read_all_parameters(self, hopper_id):
        """读取所有控制参数"""
        pass
```

**类：AddressMapper**

```python
class AddressMapper:
    """
    地址映射器
    管理参数名称与PLC地址的映射关系
    """
    
    def __init__(self, mapping_file=None):
        """初始化地址映射"""
        pass
        
    def get_address(self, param_name, hopper_id=None):
        """获取参数对应的PLC地址"""
        pass
        
    def get_data_type(self, param_name):
        """获取参数的数据类型"""
        pass
        
    def load_mapping(self, mapping_file):
        """从文件加载映射关系"""
        pass
```

#### 3.1.3 文件结构

```
communication/
├── __init__.py
├── modbus_client.py           # MODBUS RTU客户端实现
├── plc_communicator.py        # PLC通信管理器
├── address_mapper.py          # 地址映射器
├── data_converter.py          # 数据类型转换
└── error_handler.py           # 错误处理
```

#### 3.1.4 开发注意事项
- 确保通信参数（波特率、校验位等）与PLC匹配
- 实现可靠的错误处理和重试机制
- 支持不同数据类型（整数、浮点数）的读写
- 地址映射应易于维护和更新

### 3.2 数据采集模块 (DataAcquisition)

#### 3.2.1 功能描述
负责监测系统状态、检测包装周期、采集和记录包装数据。

#### 3.2.2 接口定义

**类：CycleDetector**

```python
class CycleDetector:
    """
    周期检测器
    负责检测包装周期的开始和结束
    """
    
    def __init__(self, communicator, hopper_id):
        """初始化周期检测器"""
        pass
        
    def update(self):
        """更新状态，检测周期事件"""
        pass
        
    def is_cycle_completed(self):
        """检查周期是否完成"""
        pass
        
    def get_cycle_data(self):
        """获取当前周期数据"""
        pass
        
    def reset(self):
        """重置周期检测器"""
        pass
```

**类：DataRecorder**

```python
class DataRecorder:
    """
    数据记录器
    记录包装过程中的数据
    """
    
    def __init__(self, storage_path=None):
        """初始化数据记录器"""
        pass
        
    def record_weight(self, hopper_id, timestamp, weight):
        """记录重量数据"""
        pass
        
    def record_parameters(self, hopper_id, parameters):
        """记录参数数据"""
        pass
        
    def record_cycle(self, hopper_id, cycle_data):
        """记录完整的周期数据"""
        pass
        
    def get_history_data(self, hopper_id, count=10):
        """获取历史数据"""
        pass
        
    def export_data(self, file_path, format='csv'):
        """导出数据"""
        pass
```

**类：StatusMonitor**

```python
class StatusMonitor:
    """
    状态监视器
    监视系统状态并生成事件
    """
    
    def __init__(self, communicator):
        """初始化状态监视器"""
        pass
        
    def update(self):
        """更新状态"""
        pass
        
    def get_hopper_status(self, hopper_id):
        """获取料斗状态"""
        pass
        
    def add_event_listener(self, event_type, callback):
        """添加事件监听器"""
        pass
        
    def remove_event_listener(self, event_type, callback):
        """移除事件监听器"""
        pass
```

#### 3.2.3 文件结构

```
data_acquisition/
├── __init__.py
├── cycle_detector.py      # 周期检测器
├── data_recorder.py       # 数据记录器
├── status_monitor.py      # 状态监视器
└── data_analyzer.py       # 数据分析工具
```

#### 3.2.4 开发注意事项
- 数据采集频率应足够高以捕获快速变化
- 周期检测应稳定可靠，不受噪声影响
- 数据存储格式应便于后续分析
- 添加数据备份和恢复机制

### 3.3 自适应算法模块 (AdaptiveAlgorithm)

#### 3.3.1 功能描述
实现三阶段（快加、慢加、点动）自适应控制算法，根据包装结果动态调整控制参数。

#### 3.3.2 接口定义

**类：AdaptiveController**

```python
class AdaptiveController:
    """
    自适应控制器
    实现参数自适应调整
    """
    
    def __init__(self, initial_params=None):
        """初始化自适应控制器"""
        pass
        
    def set_target(self, target_weight):
        """设置目标重量"""
        pass
        
    def adapt(self, actual_weight):
        """根据实际重量调整参数"""
        pass
        
    def get_parameters(self):
        """获取当前参数"""
        pass
        
    def set_parameters(self, parameters):
        """设置控制参数"""
        pass
        
    def reset(self):
        """重置控制器"""
        pass
```

**类：ThreeStageController**

```python
class ThreeStageController(AdaptiveController):
    """
    三阶段控制器
    实现三阶段（快加、慢加、点动）控制策略
    """
    
    def __init__(self, initial_params=None):
        """初始化三阶段控制器"""
        super().__init__(initial_params)
        
    def adapt_coarse_stage(self, error):
        """调整快加阶段参数"""
        pass
        
    def adapt_fine_stage(self, error):
        """调整慢加阶段参数"""
        pass
        
    def adapt_jog_stage(self, error):
        """调整点动阶段参数"""
        pass
        
    def get_stage_parameters(self, stage):
        """获取指定阶段的参数"""
        pass
```

**类：PIDController**

```python
class PIDController:
    """
    PID控制器
    实现PID控制算法
    """
    
    def __init__(self, kp=1.0, ki=0.0, kd=0.0):
        """初始化PID控制器"""
        pass
        
    def calculate(self, error):
        """计算PID输出"""
        pass
        
    def reset(self):
        """重置PID控制器"""
        pass
        
    def set_parameters(self, kp=None, ki=None, kd=None):
        """设置PID参数"""
        pass
```

**类：PerformanceEvaluator**

```python
class PerformanceEvaluator:
    """
    性能评估器
    评估控制性能
    """
    
    def __init__(self):
        """初始化性能评估器"""
        pass
        
    def evaluate(self, target, actual_values):
        """评估控制性能"""
        pass
        
    def get_metrics(self):
        """获取性能指标"""
        pass
        
    def reset(self):
        """重置评估器"""
        pass
```

#### 3.3.3 文件结构

```
adaptive_algorithm/
├── __init__.py
├── adaptive_controller.py     # 自适应控制器
├── three_stage_controller.py  # 三阶段控制器
├── pid_controller.py          # PID控制器
└── performance_evaluator.py   # 性能评估器
```

#### 3.3.4 开发注意事项
- 算法应具有足够的稳定性
- 参数调整应在安全范围内
- 性能评估应考虑准确度和效率
- 提供算法自调整能力

### 3.4 控制模块 (Controller)

#### 3.4.1 功能描述
实现系统的主控制逻辑，管理其他模块，协调系统整体工作。

#### 3.4.2 接口定义

**类：SystemController**

```python
class SystemController:
    """
    系统控制器
    系统的中央控制点
    """
    
    def __init__(self, config_file=None):
        """初始化系统控制器"""
        pass
        
    def initialize(self):
        """初始化系统"""
        pass
        
    def start(self):
        """启动系统"""
        pass
        
    def stop(self):
        """停止系统"""
        pass
        
    def set_target_weight(self, hopper_id, weight):
        """设置目标重量"""
        pass
        
    def activate_hopper(self, hopper_id, active=True):
        """激活/停用料斗"""
        pass
        
    def enable_adaptive_control(self, enabled=True):
        """启用/禁用自适应控制"""
        pass
        
    def update(self):
        """更新系统状态"""
        pass
        
    def load_configuration(self, config_file):
        """加载配置"""
        pass
        
    def save_configuration(self, config_file):
        """保存配置"""
        pass
```

**类：HopperController**

```python
class HopperController:
    """
    料斗控制器
    管理单个料斗的控制
    """
    
    def __init__(self, hopper_id, communicator, adaptive_controller):
        """初始化料斗控制器"""
        pass
        
    def start(self):
        """启动料斗"""
        pass
        
    def stop(self):
        """停止料斗"""
        pass
        
    def set_target_weight(self, weight):
        """设置目标重量"""
        pass
        
    def update_parameters(self):
        """更新控制参数"""
        pass
        
    def get_status(self):
        """获取料斗状态"""
        pass
        
    def enable_adaptive_control(self, enabled=True):
        """启用/禁用自适应控制"""
        pass
        
    def update(self):
        """更新料斗控制"""
        pass
```

**类：ParameterManager**

```python
class ParameterManager:
    """
    参数管理器
    管理系统参数
    """
    
    def __init__(self, storage_path=None):
        """初始化参数管理器"""
        pass
        
    def get_parameter(self, param_name, hopper_id=None):
        """获取参数值"""
        pass
        
    def set_parameter(self, param_name, value, hopper_id=None):
        """设置参数值"""
        pass
        
    def load_parameters(self, file_path):
        """从文件加载参数"""
        pass
        
    def save_parameters(self, file_path):
        """保存参数到文件"""
        pass
        
    def reset_to_default(self, hopper_id=None):
        """重置为默认参数"""
        pass
```

#### 3.4.3 文件结构

```
controller/
├── __init__.py
├── system_controller.py       # 系统控制器
├── hopper_controller.py       # 料斗控制器
├── parameter_manager.py       # 参数管理器
└── scheduler.py               # 系统调度器
```

#### 3.4.4 开发注意事项
- 系统控制应具备容错能力
- 参数变更应实时同步到PLC
- 控制逻辑应清晰易维护
- 支持多种控制模式（手动/自动）

### 3.5 用户界面模块 (UI)

#### 3.5.1 功能描述
提供用户交互界面，显示系统状态，允许参数设置和数据查看。UI模块是系统的核心组成部分，与其他功能模块同步开发，确保实时数据显示和参数调整。

#### 3.5.2 接口定义

**类：MainWindow**

```python
class MainWindow:
    """
    主窗口
    系统的主用户界面
    """
    
    def __init__(self, system_controller):
        """初始化主窗口"""
        pass
        
    def initialize(self):
        """初始化界面"""
        pass
        
    def update_display(self):
        """更新显示"""
        pass
        
    def register_data_listeners(self):
        """注册数据变化监听器"""
        pass
        
    def on_weight_changed(self, hopper_id, weight):
        """重量变化事件处理"""
        pass
        
    def on_status_changed(self, hopper_id, status):
        """状态变化事件处理"""
        pass
        
    def on_parameters_changed(self, hopper_id, parameters):
        """参数变化事件处理"""
        pass
        
    def show(self):
        """显示窗口"""
        pass
        
    def close(self):
        """关闭窗口"""
        pass
```

**类：ConnectionConfigDialog**

```python
class ConnectionConfigDialog:
    """
    连接配置对话框
    允许用户配置通信参数
    """
    
    def __init__(self, parent=None):
        """初始化连接配置对话框"""
        pass
        
    def get_connection_settings(self):
        """获取连接设置"""
        pass
        
    def set_connection_settings(self, settings):
        """设置连接设置"""
        pass
        
    def validate_settings(self):
        """验证连接设置"""
        pass
        
    def show(self):
        """显示对话框"""
        pass
        
    def on_test_connection(self):
        """测试连接按钮点击事件"""
        pass
        
    def on_save_settings(self):
        """保存设置按钮点击事件"""
        pass
        
    def on_load_settings(self):
        """加载设置按钮点击事件"""
        pass
```

**类：DataVisualizer**

```python
class DataVisualizer:
    """
    数据可视化器
    提供数据图表显示
    """
    
    def __init__(self, data_recorder):
        """初始化数据可视化器"""
        pass
        
    def plot_weight_history(self, hopper_id):
        """绘制重量历史图表"""
        pass
        
    def plot_error_history(self, hopper_id):
        """绘制误差历史图表"""
        pass
        
    def plot_parameter_history(self, hopper_id, param_name):
        """绘制参数历史图表"""
        pass
        
    def update(self):
        """更新图表"""
        pass
```

**类：ParameterEditor**

```python
class ParameterEditor:
    """
    参数编辑器
    提供参数编辑界面
    """
    
    def __init__(self, parameter_manager):
        """初始化参数编辑器"""
        pass
        
    def load_parameters(self, hopper_id):
        """加载参数"""
        pass
        
    def save_parameters(self):
        """保存参数"""
        pass
        
    def show(self):
        """显示编辑器"""
        pass
        
    def close(self):
        """关闭编辑器"""
        pass
```

**类：RealTimeMonitor**

```python
class RealTimeMonitor:
    """
    实时监控界面
    显示实时数据和系统运行状态
    """
    
    def __init__(self, data_recorder, system_controller):
        """初始化实时监控界面"""
        pass
        
    def initialize(self):
        """初始化界面"""
        pass
        
    def start_monitoring(self):
        """开始监控"""
        pass
        
    def stop_monitoring(self):
        """停止监控"""
        pass
        
    def update_display(self, data):
        """更新显示"""
        pass
        
    def set_update_interval(self, interval):
        """设置更新间隔"""
        pass
        
    def export_current_view(self, file_path):
        """导出当前视图"""
        pass
```

**类：CycleDataViewer**

```python
class CycleDataViewer:
    """
    周期数据查看器
    查看和分析包装周期数据
    """
    
    def __init__(self, data_recorder):
        """初始化周期数据查看器"""
        pass
        
    def initialize(self):
        """初始化界面"""
        pass
        
    def load_cycles(self, hopper_id, count=10):
        """加载周期数据"""
        pass
        
    def show_cycle_details(self, cycle_id):
        """显示周期详情"""
        pass
        
    def export_cycles(self, file_path, format='csv'):
        """导出周期数据"""
        pass
        
    def filter_cycles(self, criteria):
        """筛选周期数据"""
        pass
```

#### 3.5.3 文件结构

```
ui/
├── __init__.py
├── main_window.py         # 主窗口
├── connection_dialog.py   # 连接配置对话框
├── real_time_monitor.py   # 实时监控界面
├── cycle_data_viewer.py   # 周期数据查看器
├── data_visualizer.py     # 数据可视化器
├── parameter_editor.py    # 参数编辑器
├── status_monitor_ui.py   # 状态监视界面
└── styles/                # 样式文件
    ├── dark_theme.qss     # 深色主题
    └── light_theme.qss    # 浅色主题
```

#### 3.5.4 开发注意事项
- 界面设计应简洁明了，注重用户体验
- 实现数据的实时更新和显示
- 确保UI与功能模块的紧密集成
- 数据可视化应直观易懂
- 支持参数快速设置和调整
- 提供灵活的连接配置选项
- 实现异步UI更新避免界面卡顿
- 加入适当的错误提示和用户指导

## 4. 数据结构设计

### 4.1 控制参数结构

```python
# 控制参数结构
control_parameters = {
    # 快加阶段参数
    'coarse_stage': {
        'speed': 35,               # 快加速度 (0-50)
        'advance': 55.0            # 快加提前量 (g)
    },
    
    # 慢加阶段参数
    'fine_stage': {
        'speed': 18,               # 慢加速度 (0-50)
        'advance': 2.0             # 慢加提前量 (g)
    },
    
    # 点动阶段参数
    'jog_stage': {
        'strength': 18,            # 点动强度 (0-50)
        'time': 200,               # 点动时间 (ms)
        'interval': 100            # 点动间隔 (ms)
    },
    
    # 通用参数
    'common': {
        'target_weight': 500.0,    # 目标重量 (g)
        'discharge_speed': 40,     # 清料速度 (0-50)
        'discharge_time': 1000     # 清料时间 (ms)
    }
}
```

### 4.2 周期数据结构

```python
# 包装周期数据结构
cycle_data = {
    'hopper_id': 0,                # 料斗ID
    'start_time': 1619433600,      # 开始时间 (时间戳)
    'end_time': 1619433610,        # 结束时间 (时间戳)
    'target_weight': 500.0,        # 目标重量 (g)
    'final_weight': 499.5,         # 最终重量 (g)
    'error': -0.5,                 # 误差 (g)
    'parameters': {...},           # 使用的参数
    'weight_samples': [            # 重量采样数据
        (1619433601, 10.5),        # (时间戳, 重量)
        (1619433602, 150.2),
        # ...
    ]
}
```

### 4.3 状态数据结构

```python
# 系统状态数据结构
system_status = {
    'connected': True,             # 连接状态
    'running': True,               # 运行状态
    'adaptive_enabled': True,      # 自适应控制状态
    'hoppers': [                   # 料斗状态
        {
            'id': 0,
            'active': True,        # 激活状态
            'state': 'feeding',    # 当前状态 (idle/feeding/target_reached/discharging)
            'current_weight': 350.5, # 当前重量
            'target_weight': 500.0,  # 目标重量
            'adaptive_enabled': True, # 自适应控制状态
            'error': 0.0           # 最近误差
        },
        # ...
    ],
    'alarms': []                   # 报警信息
}
```

### 4.4 性能数据结构

```python
# 性能数据结构
performance_metrics = {
    'hopper_id': 0,                # 料斗ID
    'cycle_count': 100,            # 周期数
    'average_error': 0.2,          # 平均误差 (g)
    'error_std': 0.5,              # 误差标准差
    'average_cycle_time': 8.5,     # 平均周期时间 (s)
    'min_error': -1.0,             # 最小误差
    'max_error': 1.2,              # 最大误差
    'adjustment_count': 25         # 参数调整次数
}
```

## 5. 开发步骤

### 5.1 阶段一：基础设施开发

#### 5.1.1 通信模块开发
1. 实现MODBUS RTU客户端
2. 实现地址映射器
3. 实现PLC通信管理器
4. 测试基本通信功能

**所需信息**:
- PLC的通信参数（端口、波特率等）
- PLC的地址映射表（参数地址、数据类型）
- MODBUS协议细节（寄存器类型、地址范围）

#### 5.1.2 数据结构定义
1. 定义控制参数结构
2. 定义周期数据结构
3. 定义状态数据结构
4. 实现相关数据类

**所需信息**:
- 控制参数的名称、范围和默认值
- 周期数据的采集要求和格式
- 状态数据的定义和表示方式

### 5.2 阶段二：基本功能和UI实现

#### 5.2.1 基础UI框架开发
1. 实现主窗口框架
2. 实现连接配置对话框
3. 实现基本状态显示
4. 测试UI框架功能

**所需信息**:
- UI设计要求和布局
- 连接参数的范围和默认值
- 状态显示的项目和格式

#### 5.2.2 数据采集模块开发
1. 实现周期检测器
2. 实现数据记录器
3. 实现状态监视器
4. 测试数据采集功能
5. 集成UI实时数据显示

**所需信息**:
- 包装周期的判定条件
- 数据记录的频率和内容
- 状态监视的要求和事件定义
- UI更新频率要求

#### 5.2.3 控制模块基础实现
1. 实现系统控制器框架
2. 实现料斗控制器
3. 实现参数管理器
4. 测试基本控制功能
5. 集成UI参数设置界面

**所需信息**:
- 系统控制逻辑和工作流程
- 料斗控制的命令和状态
- 参数管理的要求和存储方式
- 参数设置UI的交互需求

### 5.3 阶段三：自适应算法与监控UI实现

#### 5.3.1 PID控制器实现
1. 实现PID控制算法
2. 测试PID控制效果
3. 优化PID参数
4. 开发PID参数可视化调整界面

**所需信息**:
- PID控制的要求和参数范围
- 控制目标和评价指标
- PID参数调整UI交互需求

#### 5.3.2 三阶段控制器实现
1. 实现快加阶段控制策略
2. 实现慢加阶段控制策略
3. 实现点动阶段控制策略
4. 测试三阶段控制效果
5. 开发三阶段控制可视化监控界面

**所需信息**:
- 三阶段控制的具体要求和参数
- 各阶段之间的转换条件
- 控制精度的要求
- 阶段状态可视化展示需求

#### 5.3.3 自适应控制实现
1. 实现自适应控制算法
2. 实现性能评估功能
3. 测试自适应控制效果
4. 优化自适应算法
5. 开发自适应控制监控和配置界面

**所需信息**:
- 自适应控制的目标和策略
- 参数调整的范围和步长
- 性能评估的指标和方法
- 自适应过程可视化需求

#### 5.3.4 实时监控UI实现
1. 实现实时数据图表显示
2. 实现参数变化趋势图
3. 实现控制状态可视化
4. 测试监控界面实时性能

**所需信息**:
- 实时数据显示需求
- 图表类型和布局
- 刷新频率和数据缓存策略

### 5.4 阶段四：系统集成与数据分析UI

#### 5.4.1 周期数据分析UI实现
1. 实现周期数据表格展示
2. 实现周期数据筛选和排序
3. 实现周期数据图表分析
4. 实现数据导出功能
5. 测试数据分析功能

**所需信息**:
- 数据分析的维度和指标
- 图表类型和交互方式
- 数据导出格式和内容

#### 5.4.2 系统集成
1. 集成所有功能模块和UI组件
2. 实现系统调度和事件机制
3. 测试整体功能和交互
4. 解决接口和协作问题

**所需信息**:
- 模块之间的交互方式
- 系统调度的要求和策略
- 各模块的接口定义
- UI与功能模块的事件机制

#### 5.4.3 性能优化
1. 分析系统性能瓶颈
2. 优化数据处理效率
3. 优化UI响应速度
4. 优化自适应算法
5. 测试优化效果

**所需信息**:
- 性能要求和指标
- 系统运行的限制条件
- 优化的目标和方向
- UI响应时间要求

### 5.5 阶段五：测试与部署

#### 5.5.1 全面测试
1. 设计单元测试用例并实现自动化测试
2. 执行集成测试验证模块间协作
3. 进行系统测试验证整体功能
4. 进行负载测试评估性能瓶颈
5. 实施用户界面测试确保良好体验

**所需信息**:
- 测试环境规格和配置
- 测试数据集和预期结果
- 性能和稳定性要求
- UI交互和体验标准

#### 5.5.2 容器化与部署
1. 创建Docker容器配置
2. 实现自动化构建流程
3. 准备详细部署文档
4. 环境配置和依赖管理
5. 执行系统部署和验证

**所需信息**:
- 目标部署环境详情
- 容器化需求和限制
- 网络和安全设置
- 备份和恢复策略

#### 5.5.3 用户培训与文档
1. 编写用户手册和操作指南
2. 创建管理员手册
3. 准备培训材料和示例
4. 开发常见问题解答
5. A制作视频教程和快速入门指南

**所需信息**:
- 目标用户群体信息
- 培训需求和预期
- 文档格式和分发方式
- 系统使用场景

## 6. 配置文件设计

### 6.1 连接配置界面设计

连接配置对话框允许用户灵活设置通信参数，提高系统适应性。

#### 6.1.1 界面布局

```
+--------------------------------------+
|  连接配置                             |
+--------------------------------------+
|                                      |
|  串口:    [COM3]       ▼             |
|  波特率:  [9600]       ▼             |
|  数据位:  [8]          ▼             |
|  校验位:  [无]         ▼             |
|  停止位:  [1]          ▼             |
|  超时(s): [0.5]                      |
|  从站地址: [1]                        |
|                                      |
|  [保存为默认] [加载配置] [测试连接]     |
|                                      |
|       [取消]          [确定]          |
+--------------------------------------+
```

#### 6.1.2 功能特点

- 通过下拉框选择可用串口
- 预设常用波特率（4800, 9600, 19200, 38400, 57600, 115200）
- 自动检测通信参数有效性
- 可保存多套连接配置方案
- 提供测试连接功能
- 自动保存最近使用的配置
- 支持从配置文件加载设置

#### 6.1.3 交互流程

1. 系统启动时自动显示连接配置对话框
2. 用户设置或选择通信参数
3. 用户可选择测试连接验证设置
4. 确认后参数生效，系统尝试建立连接
5. 连接成功则进入主界面，否则提示错误

### 6.2 系统配置文件 (system_config.json)

```json
{
    "communication": {
        "port": "COM3",
        "baudrate": 9600,
        "bytesize": 8,
        "parity": "N",
        "stopbits": 1,
        "timeout": 0.5,
        "slave_id": 1
    },
    "data_acquisition": {
        "sampling_interval": 0.05,
        "data_storage_path": "data/",
        "max_history_size": 1000
    },
    "adaptive_control": {
        "enabled": true,
        "pid": {
            "kp": 0.5,
            "ki": 0.1,
            "kd": 0.2
        },
        "adjustment_limits": {
            "coarse_speed": [10, 50],
            "fine_speed": [5, 30],
            "jog_strength": [5, 25],
            "coarse_advance": [20, 100],
            "fine_advance": [0.5, 10]
        }
    },
    "logging": {
        "level": "INFO",
        "file": "logs/system.log",
        "max_size": 10485760,
        "backup_count": 5
    }
}
```

### 6.2 地址映射文件 (address_mapping.json)

```json
{
    "registers": {
        "weight_data": {
            "addresses": [700, 702, 704, 706, 708, 710],
            "type": "float32",
            "access": "read"
        },
        "coarse_speed": {
            "addresses": [300, 320, 340, 360, 380, 400],
            "type": "float32",
            "access": "read_write"
        },
        "fine_speed": {
            "addresses": [302, 322, 342, 362, 382, 402],
            "type": "float32",
            "access": "read_write"
        },
        "coarse_advance": {
            "addresses": [500, 504, 508, 512, 516, 520],
            "type": "float32",
            "access": "read_write"
        },
        "fine_advance": {
            "addresses": [502, 506, 510, 514, 518, 522],
            "type": "float32",
            "access": "read_write"
        },
        "target_weight": {
            "addresses": [141, 142, 143, 144, 145, 146],
            "type": "float32",
            "access": "read_write"
        },
        "jog_time": {
            "address": 70,
            "type": "float32",
            "access": "read_write"
        },
        "jog_interval": {
            "address": 72,
            "type": "float32",
            "access": "read_write"
        },
        "discharge_speed": {
            "address": 290,
            "type": "float32",
            "access": "read_write"
        },
        "discharge_time": {
            "address": 80,
            "type": "float32",
            "access": "read_write"
        }
    },
    "coils": {
        "master_start": {
            "address": 300,
            "access": "write"
        },
        "master_stop": {
            "address": 301,
            "access": "write"
        },
        "master_zero": {
            "address": 6,
            "access": "write"
        },
        "master_discharge": {
            "address": 5,
            "access": "write"
        },
        "master_clean": {
            "address": 7,
            "access": "write"
        },
        "hopper_start": {
            "addresses": [110, 111, 112, 113, 114, 115],
            "access": "write"
        },
        "hopper_stop": {
            "addresses": [120, 121, 122, 123, 124, 125],
            "access": "write"
        },
        "hopper_zero": {
            "addresses": [181, 182, 183, 184, 185, 186],
            "access": "write"
        },
        "hopper_discharge": {
            "addresses": [51, 52, 53, 54, 55, 56],
            "access": "write"
        },
        "hopper_clean": {
            "addresses": [61, 62, 63, 64, 65, 66],
            "access": "write"
        }
    }
}
```

### 6.3 控制参数文件 (control_parameters.json)

```json
{
    "global": {
        "jog_time": 200,
        "jog_interval": 100,
        "discharge_speed": 40,
        "discharge_time": 1000
    },
    "hoppers": [
        {
            "id": 0,
            "target_weight": 500.0,
            "coarse_speed": 35,
            "fine_speed": 18,
            "coarse_advance": 55.0,
            "fine_advance": 2.0
        },
        {
            "id": 1,
            "target_weight": 500.0,
            "coarse_speed": 35,
            "fine_speed": 18,
            "coarse_advance": 55.0,
            "fine_advance": 2.0
        },
        {
            "id": 2,
            "target_weight": 500.0,
            "coarse_speed": 35,
            "fine_speed": 18,
            "coarse_advance": 55.0,
            "fine_advance": 2.0
        },
        {
            "id": 3,
            "target_weight": 500.0,
            "coarse_speed": 35,
            "fine_speed": 18,
            "coarse_advance": 55.0,
            "fine_advance": 2.0
        },
        {
            "id": 4,
            "target_weight": 500.0,
            "coarse_speed": 35,
            "fine_speed": 18,
            "coarse_advance": 55.0,
            "fine_advance": 2.0
        },
        {
            "id": 5,
            "target_weight": 500.0,
            "coarse_speed": 35,
            "fine_speed": 18,
            "coarse_advance": 55.0,
            "fine_advance": 2.0
        }
    ]
}
```

## 7. 测试计划

### 7.1 单元测试

| 模块 | 测试内容 | 预期结果 |
| ---- | -------- | -------- |
| 通信模块 | MODBUS通信功能 | 能正确读写不同类型的数据 |
| 通信模块 | 错误处理和重试 | 在通信错误时能正确处理和重试 |
| 数据采集模块 | 周期检测 | 能正确检测包装周期的开始和结束 |
| 数据采集模块 | 数据记录 | 能正确记录和存储包装数据 |
| 自适应算法模块 | PID控制 | PID控制器能正确计算输出 |
| 自适应算法模块 | 参数调整 | 能根据误差正确调整参数 |
| 控制模块 | 系统控制 | 能正确启动和停止系统 |
| 控制模块 | 料斗控制 | 能正确控制各个料斗 |

### 7.2 集成测试

| 测试内容 | 预期结果 |
| -------- | -------- |
| 通信与数据采集集成 | 能正确读取PLC数据并进行周期检测 |
| 数据采集与自适应算法集成 | 能根据采集的数据正确调整参数 |
| 自适应算法与控制模块集成 | 能将调整后的参数正确应用到控制中 |
| 控制模块与通信模块集成 | 能将控制命令正确发送到PLC |
| 完整系统集成 | 系统各模块能协同工作，实现自适应控制 |

### 7.3 系统测试

| 测试内容 | 预期结果 |
| -------- | -------- |
| 系统启动和停止 | 系统能正常启动和停止，无异常 |
| 参数设置 | 能正确设置和保存参数 |
| 自适应控制 | 系统能根据包装结果自动调整参数 |
| 长时间运行稳定性 | 系统能长时间稳定运行，无内存泄漏或性能下降 |
| 异常处理 | 在各种异常情况下系统能正确处理并恢复 |

### 7.4 验收测试

| 测试内容 | 预期结果 | 验收标准 |
| -------- | -------- | -------- |
| 控制精度 | 包装重量误差在目标范围内 | 95%的包装重量误差 < ±0.5g |
| 包装效率 | 包装速度达到目标值 | 每分钟至少20包 |
| 自适应能力 | 能适应不同物料特性 | 切换物料后3个周期内误差收敛 |
| 系统稳定性 | 系统长时间运行无故障 | 连续运行24小时无故障 |
| 用户体验 | 操作简便，界面友好 | 用户无需额外培训即可操作 |

## 8. 开发环境与依赖

### 8.1 开发环境

- 操作系统: Windows 11
- Python版本: 3.8+
- 开发工具: Visual Studio Code, PyCharm等
- 版本控制: Git

### 8.2 依赖库

- PyModbus: 用于MODBUS RTU通信
- NumPy: 用于数值计算
- Pandas: 用于数据处理和分析
- Matplotlib: 用于数据可视化
- PyQt5/Tkinter: 用于GUI开发(可选)
- PySerial: 用于串口通信
- pytest: 用于单元测试

## 9. 需要提供的信息

### 9.1 硬件信息
- PLC型号和固件版本
- 通信接口参数（串口、波特率等）
- 其他硬件限制条件

### 9.2 PLC地址映射
- 各参数对应的PLC地址
- 地址类型（寄存器、线圈等）
- 数据类型（整数、浮点数等）
- 读写权限

### 9.3 控制参数范围
- 各控制参数的有效范围
- 默认参数值
- 参数调整步长

### 9.4 工作流程细节
- 包装周期的详细描述
- 状态转换条件
- 特殊操作处理方式

### 9.5 性能要求
- 控制精度要求
- 包装效率要求
- 系统响应时间要求

## 10. 实时监控界面设计

### 10.1 实时监控界面布局

实时监控界面是系统的核心操作界面，集成了数据显示、参数调整和控制功能。

```
+-----------------------------------------------------------------------+
|  颗粒称重包装机自适应控制系统                             [设置] [帮助]  |
+---------------+-------------------------------+------------------------+
| 料斗状态       | 实时重量图                    | 参数监控               |
|               |                               |                        |
| □ 料斗1 运行中 |                               | 快加速度: 35           |
| □ 料斗2 停止   |                               | 慢加速度: 18           |
| □ 料斗3 停止   |                               | 点动强度: 18           |
| □ 料斗4 停止   |                               | 快加提前量: 55.0g      |
| □ 料斗5 停止   |                               | 慢加提前量: 2.0g       |
| □ 料斗6 停止   |                               | 目标重量: 500.0g       |
|               |                               |                        |
| 总控制:        |                               | 自适应状态:            |
| [启动] [停止]  |                               | [开启] [关闭]          |
+---------------+-------------------------------+------------------------+
| 当前周期数据                                   | 系统状态: 正常运行中    |
+-----------------------------------------------------------------------+
| 料斗1: 目标重量: 500.0g | 当前重量: 352.5g | 状态: 快加阶段           |
| 上次包装重量: 499.8g | 误差: -0.2g | 周期用时: 7.5s | 阶段: 完成      |
+-----------------------------------------------------------------------+
| [参数设置] [数据分析] [加载预设] [保存预设] [导出数据]                  |
+-----------------------------------------------------------------------+
```

### 10.2 实时监控功能特点

- 实时重量曲线图，显示包装过程中的重量变化
- 颜色标识不同加料阶段（快加、慢加、点动）
- 自动调整参数实时显示和可视化比较
- 周期完成后自动更新性能指标
- 支持多料斗并行监控和独立控制
- 参数变化趋势分析图表
- 故障状态实时提示和记录
- 快捷参数调整控件

### 10.3 数据流设计

- 采用观察者模式实现数据变化通知
- 使用数据缓冲区减少UI刷新压力
- 图表数据支持可变时间窗口（近期/全程）
- 关键数据变化触发声音或视觉提醒
- 实现数据筛选和聚焦功能

## 11. 注意事项与建议

### 11.1 开发注意事项
- 确保通信可靠性，实现稳定的错误处理
- 在参数调整时考虑安全限制
- 数据采集速率应足够快以捕获状态变化
- 自适应算法应避免过快或过大的调整
- UI更新与后台处理应分离，避免界面卡顿

### 11.2 优化建议
- 使用异步通信提高系统响应性
- 实现数据缓存减少通信开销
- 优化算法收敛速度
- 添加参数预设功能以适应不同物料
- 使用多线程处理UI更新和数据采集
- 采用图形缓冲技术提高UI渲染效率

### 11.3 扩展性考虑
- 设计模块化接口便于未来扩展
- 预留新功能的接口
- 支持更多的控制策略
- 允许用户自定义算法参数
- UI组件设计支持主题切换和布局调整
- 为远程监控预留接口

## 12. 开发中需要的其他信息和资源

本节列出了在开发过程中可能需要的额外信息和资源。在实际开发前，请确保这些信息和资源已经准备就绪。

### 12.1 PLC编程手册
- MODBUS地址映射详细说明
- PLC内部逻辑说明
- 通信协议细节

### 12.2 设备操作手册
- 设备操作流程
- 参数设置说明
- 故障处理方法

### 12.3 现有代码和资源
- 任何现有的通信代码
- 参数配置文件
- 历史数据样本
- UI设计素材和图标资源

### 12.4 测试环境
- 测试用PLC或模拟器
- 测试数据集
- 性能测试工具
- UI自动化测试工具
