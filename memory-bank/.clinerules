# 项目特定规则

## 项目偏好和模式

1. **命名规范**：(待根据 `old` 代码库实际情况检查和确认)
   - 类名：驼峰命名法（CamelCase），如 `CommunicationManager`, `CycleMonitor` (似乎符合)
   - 方法名：小写下划线命名法（snake_case），如 `connect()`, `_monitor_data()` (似乎符合)
   - 常量：大写下划线命名法（UPPER_SNAKE_CASE），如 `PHASE_COARSE` (似乎符合)
   - 变量：小写下划线命名法（snake_case），如 `is_connected`, `hopper_id` (似乎符合)

2. **文档规范**：(待根据 `old` 代码库实际情况检查和确认)
   - 类和方法倾向于使用中文文档字符串。
   - 类型标注的使用情况不一。

3. **代码风格**：(待根据 `old` 代码库实际情况检查和确认)
   - 缩进：倾向于使用 4 空格。
   - 行长度：可能存在超过 120 字符的情况。

4. **异常处理**：
   - 主要使用 `try...except` 块捕获异常。
   - 倾向于打印错误信息 (`print`, `logging`) 而不是定义复杂的自定义异常层次。
   - `CommunicationManager` 中包含一些错误重试逻辑。

5. **开发环境**：
   - 使用 Python 虚拟环境 (.venv) 进行开发。
   - 依赖库版本锁定在 `requirements.txt` 中。

## 关键实现路径

1. **通信与数据流路径**：
   - PLC -> `CommunicationManager._monitor_data` -> `WeightDataEvent` -> `EventDispatcher` -> `CycleMonitor._on_weight_data` / `MonitorTab` 等 UI 组件
   - UI 操作 -> (Tkinter event) -> Tab 类方法 (e.g., `_on_connect_clicked`) -> `CommunicationManager` 方法 (e.g., `connect`, `send_command`, `write_parameters`) -> PLC
2. **周期状态机路径** (`CycleMonitor`)：
   - `_on_weight_data` 接收事件 -> `_determine_phase` 判断新阶段 -> `_handle_phase_change` 更新状态和发布事件 / `_finish_cycle` 结束周期和保存。
3. **错误处理流程**：
   - 通信错误 -> `CommunicationManager` 内部重试/日志/`ConnectionEvent(False)` -> UI 状态更新。
   - 其他逻辑错误 -> `try...except` 捕获并打印日志。
4. **配置加载路径**: `config.json` -> `ConfigManager.load` -> `WeighingSystemApp.config` -> 各组件初始化时读取。
5. **地址映射**: **硬编码**在 `CommunicationManager` 的 `register_map` 和 `control_map` 字典中。

## 已知挑战

1. **通信稳定性**: 串口/网络通信可能受硬件和环境影响（通用挑战）。
2. **数据转换**: `_convert_plc_weight` 的逻辑需要确保对所有 PLC 数据（包括负数）都正确。
3. **地址映射维护**: **硬编码**地址，如果 PLC 程序变更，需要直接修改 `comm_manager.py` 代码。
4. **性能优化**: Tkinter 在高频 UI 更新时可能有性能瓶颈；`CommunicationManager` 的轮询间隔和处理逻辑影响实时性。
5. **测试覆盖率**: 可能缺乏足够的自动化测试。
6. **Tkinter UI Bug**: 存在已知的关闭时销毁错误。
7. **代码复杂度**: `CommunicationManager` 和 `CycleMonitor` 类承担了较多职责，可能变得复杂。

## 决策演变

1. **地址映射管理**：
   - 初始设计（可能）: 期望从外部文件加载。
   - **当前实现**: **硬编码**在 `CommunicationManager` 中。
   - 未来方向: （可选）重构为从配置文件加载。
2. **错误处理策略**：
   - **当前实现**: 主要通过 `try...except` 和日志/事件通知。
   - 未来方向: （可选）引入更结构化的异常处理或错误恢复机制。
3. **通信接口设计**：
   - **当前实现**: `CommunicationManager` 封装了 Modbus 客户端，提供面向应用的方法。
4. **依赖管理**：
   - 使用虚拟环境和 `requirements.txt`。
5. **UI 技术栈**: 
   - 初始设计（可能）: 考虑过或规划过 PyQt5。
   - **当前实现**: 使用 **Tkinter (ttk)**。

## 配置管理观察

1.  **PLC 连接参数来源**: 通过 `config.json` 文件进行外部配置，由 `ConfigManager` 加载。
2.  **地址映射来源**: **硬编码**在 `CommunicationManager` 类的 `register_map` 和 `control_map` 字典中。没有使用外部映射文件。
3.  **其他配置**: UI 显示参数、数据保存选项等也在 `config.json` 中。

# Algorithm and Parameter Constraints

## Speed Parameter Limits
- 快加速度参数(feeding_speed_coarse)必须小于等于50，超过则料斗不工作
- 慢加速度参数(feeding_speed_fine)必须小于等于50，超过则料斗不工作
- 所有涉及参数调整的方法中都必须添加速度参数硬限制检查
- 在边界定义中使用min(50.0, config["max_feeding_speed"])确保不超过限制

## Algorithm Tuning Best Practices
- 粗搜索到精搜索的转换阈值不应高于0.7，避免长时间停留在粗搜索阶段
- 稳定性评估窗口大小设为5，平衡稳定性评估和系统响应能力
- 快加速度和快加提前量的参数调整权重应高于其他参数
- 大偏差(>30%)情况需特殊处理，使用更激进的调整策略
- 应设置粗搜索最大周期数(8次)，防止系统无法自动进入精搜索阶段

## Learning Rate Guidelines
- 粗搜索阶段使用较大学习率(1.5)，加快收敛
- 精搜索阶段使用中等学习率(0.5)，平衡精度和速度
- 维持阶段使用小学习率(0.1)，避免过度调整

## Test Data Insights
- 系统一般需要约20个包装周期才能达到稳定状态
- 初始参数设置对收敛速度影响显著，合理设置初始值很重要
- 在收集测试数据时，应跟踪至少30个连续包装周期以评估稳定性
- 比较不同参数策略时，应在相同条件下测试至少20个周期

# Code Implementation Patterns

## Controller Class Hierarchy
- 控制器类继承关系：BaseController -> AdaptiveController -> AdaptiveThreeStageController
- 所有控制器类应实现update()、get_current_params()、reset()接口
- 新增控制器时应在__init__.py中注册并保持接口一致

## Data Management
- 使用DataManager处理所有与数据存储相关的操作
- 采用CSV格式存储重量数据，便于后续分析
- 使用JSON格式存储参数配置

## Error Handling
- 对关键方法实现try-except保护
- 详细记录异常信息，包括参数值和状态
- 在日志中使用ERROR级别报告异常情况

## Testing Approaches
- 使用PackagingSimulator类模拟包装过程，便于算法测试
- 创建完整的测试用例覆盖各种场景（正常、极限、异常）
- 使用matplotlib进行数据可视化和分析

# Project Workflow

## Algorithm Development
1. 先在模拟环境中测试算法性能
2. 在真实环境中小规模测试
3. 收集测试数据进行分析和优化
4. 再次测试并迭代改进

## Performance Tuning
1. 首先优化包装准确性
2. 其次优化系统稳定性
3. 最后优化包装效率
4. 进行平衡性能测试验证

## Documentation
- 所有算法参数调整需记录在algorithm_tuning_log.md文件中
- 算法性能分析结果记录在自适应算法性能分析.md文件中
- 代码中添加详细注释解释关键逻辑和参数作用