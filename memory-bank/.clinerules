# 项目特定规则

## 项目偏好和模式

1. **命名规范**：
   - 类名：使用驼峰命名法（CamelCase），如ModbusRTUClient
   - 方法名：使用小写下划线命名法（snake_case），如connect_device()
   - 常量：使用大写下划线命名法（UPPER_SNAKE_CASE），如MAX_RETRY_COUNT
   - 变量：使用小写下划线命名法（snake_case），如retry_count

2. **文档规范**：
   - 所有类和方法都使用中文文档字符串
   - 参数和返回值必须有类型标注和说明
   - 类文档应该包含一般性描述，方法文档应该描述功能和用法

3. **代码风格**：
   - 使用4空格缩进
   - 最大行长度为120字符
   - 导入顺序：标准库、第三方库、本地模块

4. **异常处理**：
   - 使用自定义异常类层次结构
   - 底层模块捕获并转换为自定义异常
   - 日志记录与异常抛出分离

5. **开发环境**：
   - 使用Python虚拟环境(.venv)进行开发
   - 依赖库版本锁定在requirements.txt中
   - pymodbus库固定使用2.5.3版本，因为新版本改变了导入路径

## 关键实现路径

1. **通信模块实现路径**：
   - ModbusRTUClient → PLCCommunicator → 应用层控制组件
   - 数据转换流程：PLC寄存器 → DataConverter → Python数据类型
   - 地址映射流程：参数名 → AddressMapper → PLC地址 → ModbusRTUClient

2. **错误处理流程**：
   - 通信错误 → ModbusRTUClient重试机制 → 如失败则ErrorHandler处理
   - 数据转换错误 → 返回None并记录日志 → 调用者处理

3. **日志记录方式**：
   - 使用Python标准logging模块
   - 每个类有自己的logger实例
   - 错误级别：DEBUG/INFO/WARNING/ERROR/CRITICAL

4. **测试流程**：
   - 使用ModbusSlave模拟器进行通信测试
   - 保持寄存器测试：配置地址700-709用于重量数据，地址141-146用于目标重量
   - 线圈测试：配置地址0-310用于命令控制（如果需要测试线圈功能）

## 已知挑战

1. **通信稳定性**：
   - 串口通信可能受硬件和环境因素影响
   - 解决方案：增加超时和重试机制，添加连接状态监测

2. **数据类型转换**：
   - 不同PLC型号可能使用不同的字节序
   - 解决方案：在DataConverter中支持可配置的字节序选项

3. **PLC地址映射**：
   - 不同项目可能使用不同的PLC地址分配
   - 解决方案：使用配置文件方式支持地址映射自定义

4. **性能优化**：
   - Python GIL在高频数据处理时可能成为瓶颈
   - 解决方案：批处理操作，减少通信次数，优化数据处理算法

5. **测试环境与生产环境差异**：
   - ModbusSlave模拟器可能与实际PLC设备存在差异
   - 解决方案：在部署前进行实际设备连接测试，验证所有功能

## 决策演变

1. **地址映射管理**：
   - 初始决策：硬编码地址映射
   - 演变：实现AddressMapper支持从文件加载配置
   - 未来方向：支持UI界面配置地址映射

2. **错误处理策略**：
   - 初始决策：简单的异常处理
   - 演变：实现ErrorHandler类和重试机制
   - 未来方向：增加更智能的错误恢复策略

3. **通信接口设计**：
   - 初始决策：直接使用pymodbus库接口
   - 演变：封装PLCCommunicator提供高级接口
   - 未来方向：支持更多通信协议和接口类型

4. **依赖管理**：
   - 初始决策：直接使用系统Python环境
   - 演变：创建虚拟环境和requirements.txt
   - 未来方向：考虑使用Docker容器化部署 